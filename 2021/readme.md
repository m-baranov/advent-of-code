# Advent of Code 2021

https://adventofcode.com/2021

To run: 
1. Make sure .NET 5 SDK is installed;
2. Authenticate on the site, lookup `session` cookie and set it as the environment variable `ADVENT_OF_CODE_SESSION`;
3. Edit Program.cs to select Day, Part and input data to run. Solutions follow the general naming pattern of `DayXX.PartY`.


# Impressions

This is the first year I participated in the event while it was going on. I was able to complete all puzzles (both parts) on the day they were published. Here are some of my thoughts on the puzzles I found notable.

**Most interesting:**
1. **[Day 24](https://adventofcode.com/2021/day/24) "Arithmetic Logic Unit" and [Day 8](https://adventofcode.com/2021/day/8) "Seven Segment Search"** -- I found these two the most interesting because in both cases most of the work towards solving the issue has to be done manually. This is especially the case with Day 24, where the code is trivial to write, once you understand what the puzzle actually is. And, of course, it got me -- I did write an interpreter, which was 100% unnecessary.   
2. **[Day 23](https://adventofcode.com/2021/day/23) "Amphipod"** -- although the solution I ended up with is relatively "standard" -- just use recursion, enumerate all possibilities, and pick the best one -- I found this one quite interesting and satisfying. I liked how the provided illustrations representing the burrow as a 2D grid may lead you to model it as such in your code, which will make the actual implementation way more complicated than it actually is. The need to prioritize "enter the room" moves of entering a room, over moves where the room is exited, was also not obvious at first. It was cool when the realization finally "clicked". The twist of Part 2 got me. I initially wrote the logic that determined if a creature can exit or enter a room in a way that assumed only 2 cells per room.
3. **[Day 6](https://adventofcode.com/2021/day/6) "Lanternfish", [Day 14](https://adventofcode.com/2021/day/14) "Extended Polymerization" and [Day 21](https://adventofcode.com/2021/day/21) "Dirac Dice"** -- what I find interesting about these puzzles it's the fact that these are essentially the same puzzle in a different disguise. Each defines a process that happens iteratively, each iteration takes in some state as input, follows some simple rules to produce the next state as an output, which in turn is fed into the next iteration. The size of the produced state grows exponentially; while the naive approach of generating the entire state works for Part 1, it becomes too time/memory-consuming for Part 2. The key insight for each is to realize that the state is composed of lots of repeating parts (be it fish, born on the same day, or a pair of polymers that goes one after another in the sequence, or a combination of player's score and position on the board), and there is a finite and relatively small set of such parts that are possible. So instead of trying to generate the entire new state each iteration, one has to track how many times each of these unique parts appear in the new state.  

Honorable mentions:
1. **[Day 17](https://adventofcode.com/2021/day/17) "Trick Shot"** -- I initially tried to recall (but eventually looked up) the maths for the accelerated movement, and derive some solution out of these equations. I spent some noticeable amount of time with that before just printing out how y coordinate of a shot changes with time at different initial velocities. That clued me in on a much simpler approach: you'll always return back to y=0, and will know y-acceleration at that time. If y-acceleration is such that you'll shoot over the specified area in the next immediate time increment, you know that you'll never hit it. This defines a finite (and relatively small) set of initial y-velocities to try in a brute-force-style solution.  
2. **[Day 16](https://adventofcode.com/2021/day/16) "Packet Decoder" and [Day 18](https://adventofcode.com/2021/day/18) "Snailfish"** -- compared to all of the above, there is no particular "trick" to these puzzles, I think. You know exactly what to do to solve the puzzle, there is no need to seek any insight, it's all about careful execution. That quality is not necessarily unique to these two days: there are plenty of puzzles that are just like that, but significantly easier to implement, and, there are some that are way harder (see below). What makes these two interesting for me is the balance between the amount of work required -- not too little to make it uninteresting, not too much to make it tiring or tedious.

**Most difficult:** 
1. **[Day 22](https://adventofcode.com/2021/day/22) "Reactor Reboot"** -- the algorithm for intersecting cubes was tricky and tedious to get right on my own, because of a large number of possible cases to consider. I figured out the approach that ended up being efficient enough for Part 2 almost from the beginning, but it took a lot of time to get it right. I even ended up implementing a completely different solution, that worked fast on the example provided in Part 2 but took too long to complete on the input data set. I used this second solution to cross-check with the results of the first one, to hunt down some of the bugs in the latter. 
2. **[Day 19](https://adventofcode.com/2021/day/19) "Beacon Scanner"** -- it took me some time to arrive at the key insight to look at vectors formed by two points as something that should be common between all scans. But, besides that, there is a lot to this task that is not difficult, but tedious and error-prone: rotation of points around axis, coordinate system conversions, finding transitive conversions between arbitrary scanner coordinate systems from a set of direct ones, etc. Finally, the solution took noticeable time to optimize so that it completes in a reasonable amount of time (under 15 seconds; initially it ran for multiple minutes). Yet, it still takes the longest to complete across all solutions this year.   
3. **[Day 23](https://adventofcode.com/2021/day/23) "Amphipod"** -- although this one took significantly less time than the previous two, it took me the longest time to figure out the key insight: when enumerating all possible moves, if some creature can enter a room, this move has to be taken, and no other moves need to be considered at this point. This was the key to having a solution that works fast enough. I made the key assumptions from the get-go: the layout is basically a straight line, not a 2D grid shown in the examples; there is no need to represent it as a grid or implement a generic algorithm to find the shortest distances between points. That said, it took two attempts to come up with an appropriate model and a few more to find and fix some of the minor defects in the implementation. 

**Most disappointing:**
1. **[Day 15](https://adventofcode.com/2021/day/15) "Chiton"** -- a naive implementation of the Dijkstra algorithm that uses a normal queue (which I learned a long time ago while I was at school) is not fast enough for Part 2. One has to use [a version with the min-priority queue](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Using_a_priority_queue). Although an actual [priority queue](https://en.wikipedia.org/wiki/Priority_queue) implementation is not required, you still need to prioritize pending locations to visit and pick the ones with the shortest current distance first for the algorithm to be fast enough to complete in a reasonable amount of time. I was not able to arrive at this conclusion myself and this is the first time I had to look up a specific algorithm to solve the AoC puzzle -- once my naive version of the Dijkstra algorithm failed to complete on the input of Part 2, I took to Wikipedia to look for some possible optimizations or related algorithms.   
2. **[Day 10](https://adventofcode.com/2021/day/10) "Syntax Scoring"** -- a well-known problem called "Balanced Brackets", with a well-known solution. 

